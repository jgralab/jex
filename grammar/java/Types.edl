module java/Types

imports
  java/Packages          %% PackageName
  java/Identifiers       %% Id

global actions
  pattern _ -> PrimType
    #$ = {return primTypes.get(#$0#);};#

exports
  sorts
    PrimType
    ArrayType
    ClassifierType
    TypeArg
    TypeParam

  context-free syntax

    %% Type
    rule PrimType       -> Type #$=$0;#
    rule ArrayType      -> Type #$=$0;#
    rule ClassifierType -> Type #$=$0;#

    %% Primitive types
    rule "boolean"                        -> PrimType
    rule "int"                            -> PrimType
    rule "long"                           -> PrimType
    rule "char"                           -> PrimType
    rule "byte"                           -> PrimType
    rule "short"                          -> PrimType
    rule "float"                          -> PrimType
    rule "double"                         -> PrimType
    rule "void"                           -> PrimType

    %% ArrayType
    rule PrimType        -> NonArrayType #$=$0;#
    rule ClassifierType  -> NonArrayType #$=$0;#
    rule NonArrayType #$ = ArrayType();
                       HasElementType($, $0);
                       $.name = $0.name;
                       $.qualifiedName = $0.qualifiedName;
                       $dims = 0;#
         ("[" "]" #$dims = {return ((Integer) #$dims#) + 1;};
                   $.name = $.name.concat("[]");
                   $.qualifiedName = $.qualifiedName.concat("[]");#)+
         #$.dimensions = $dims;# -> ArrayType
    rule NonArrayType "..."
         #$ = ArrayType();
          $.name = $0.name.concat("[]");
          $.qualifiedName = $0.qualifiedName.concat("[]");
          $.dimensions = 1;
          HasElementType($, $0);#
         -> ArrayType

    %% ClassifierType
    rule Id                             -> PlainClassifierType
         %% This could be a simple name of a Classifier or a type parameter name.
         #{if (#typeParams.use($0)# != null)
               #$ = typeParams.use($0);#
           else
               #$ = {return resolveClassifier(#$0#, currentElement);};#}#
    rule PackageName "." Id             -> PlainClassifierType
         #$ = {return resolveClassifier(#$0.concat(".").concat($2)#, currentElement);};#
    rule PlainClassifierType -> ClassifierType #$ = $0;#
    rule #$ = ParametrizedType();#
         PlainClassifierType
         #HasGenericType($, $0);#
         "<" {(TypeArg #HasTypeArg($, $0);#) ","}+ ">"
         -> ClassifierType #{setParametrizedTypeName(#$#);}#

    %% TypeArg
    rule Type                         -> TypeArg #$ = $0;#
    rule "?" #$ = {if (#name2NamedElement.use("?")# != null) {
                       return #name2NamedElement.use("?")#;
                   } else {
                       Vertex x = (Vertex) #WildcardType()#;
                       SymbolTableStack stck = (SymbolTableStack) #name2NamedElement#;
                       stck.declare("?", x);
                       return x;
                   }};
              $.name = "?";
              $.qualifiedName = "?";#
         ((UpperWildcardBound #HasUpperBound($, $0);#)
          | (LowerWildcardBound #HasLowerBound($, $0);#))?
         -> TypeArg
    rule "extends" ClassifierType     -> UpperWildcardBound #$ = $1;#
    rule "super"   ClassifierType     -> LowerWildcardBound #$ = $1;#

    %% TypeParam
    rule Id
         #$ = TypeParameter();
          $.name = $0;
          $.qualifiedName = {return curQName + "." + #$0#;};
          typeParams.declare($.name, $);#
         ("extends" {(ClassifierType
                      #HasBound($, $0);#) "&"}+)?  -> TypeParam
