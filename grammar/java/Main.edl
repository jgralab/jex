module java/Main
schema de.uni_koblenz.simple_java.schema.JavaSchema

imports
  java/CompilationUnits   %% CompilationUnit
  java/WhiteSpace
  java/Comments

symbol tables
  name2Package<Package>
  name2NamedElement<NamedElement>
  name2Member<Member<--Declares>:Type
  importedPackages<Package>
  importedClassifiers<Classifier>

default values
  Imports.lineNo = line(omega);
  Defines.lineNo = line(omega);

import declarations
  java.util.List;
  de.uni_koblenz.jgralab.TemporaryVertex;
  de.uni_koblenz.edl.parser.Position;
  de.uni_koblenz.edl.parser.stack.elements.StackElement;

user code {
  private Vertex defaultPackage;
  
  {
    defaultPackage = createVertex("Package", new Position());
    defaultPackage.setAttribute("name","");
    defaultPackage.setAttribute("qualifiedName","");
  }
  
  private boolean isPackageDeclaration = false;
  private String packagePrefix;
  private int statements = 0;

  @SuppressWarnings("unchecked")
  @Override
  public void finalize() {
    List<TemporaryVertex> tempVertices = (List<TemporaryVertex>)
      #name2NamedElement.getTemporaryVertices()#;
    for (TemporaryVertex tempVert: tempVertices) {
      if (tempVert.getPreliminaryType() != null) {
        tempVert.bless();
      } else {
        tempVert.bless(getVertexClass("Class"));
      }
    }
    List<TemporaryVertex> tempPackages = (List<TemporaryVertex>)
      #name2Package.getTemporaryVertices()#;
    for (TemporaryVertex tempPackage: tempPackages) {
      tempPackage.bless(getVertexClass("Package"));
    }
    for (Vertex tmp : getGraph().vertices(graph.getGraphClass()
                                .getTemporaryVertexClass())) {
      System.out.println("Left over TemporaryVertex: " + tmp);
    }
    for (Edge tmp : getGraph().edges(graph.getGraphClass()
                                .getTemporaryEdgeClass())) {
      System.out.println("Left over TemporaryEdge: " + tmp);
      System.out.println("  alpha: " + tmp.getAlpha());
      System.out.println("  omega: " + tmp.getOmega());
    }
  }

  static String stripTypeParams(Object typeSpec) {
    String ts = (String) typeSpec;
    int idx = ts.indexOf('<');
    if (idx != -1)
      ts = ts.substring(0, idx);
    // System.out.println("Stripped TypeSpec " + typeSpec + " to " + ts);
    return ts;
  }

  // Rips out the simple name of a qualified name, possibly including type parameters
  static String getSimpleName(Object qn) {
    String qname = stripTypeParams(qn);
    int idx = qname.lastIndexOf('.');
    if (idx != -1)
      qname = qname.substring(idx + 1);
    // System.out.println("Stripped QName " + qn + " to simple name " + qname);
    return qname;
  }

  static boolean isQualified(Object qn) {
    return ((String) qn).indexOf('.') != -1;
  }

  Class reflectiveGetType(String qn) {
    try {
      return Class.forName(qn);
    } catch (ClassNotFoundException e) {
      return null;
    }
  }

  Vertex getOrCreateClassifierVertex(String qn, StackElement ce) {
    Class cls = reflectiveGetType(qn);
    if (cls == null) throw new RuntimeException("Unknown classifier: " + qn);

    // Maybe there's already an existing vertex for this classifier
    Vertex vx = ((SymbolTableStack) #name2NamedElement#).use(qn);
    if (vx != null) {
      // TODO: Maybe check if the type and attr vals are correct...
      return vx;
    }

    TemporaryVertex x = createTemporaryVertex(ce.getPosition());
    if (cls.isInterface())
      x.setPreliminaryType(getVertexClass("Interface"));
    else if (cls.isEnum())
      x.setPreliminaryType(getVertexClass("Enum"));
    else if (cls.isAnnotation())
      x.setPreliminaryType(getVertexClass("Annotation"));
    else
      x.setPreliminaryType(getVertexClass("Class"));

    x.setAttribute("qualifiedName", qn);
    x.setAttribute("name", getSimpleName(qn));
    ((SymbolTableStack) #name2NamedElement#).declare(qn, x);
    return x;
  }

  Vertex getRefedType(Object typeSpec, Object currentElement) {
    String tn = stripTypeParams(typeSpec);
    StackElement ce = (StackElement) currentElement;
    Vertex x = null;

    // Is tn already fully qualified?
    if (reflectiveGetType(tn) != null) {
      x = getOrCreateClassifierVertex(tn, ce);
      return x;
    }

    // Is it an imported class foo.bar.Baz?
    x = ((SymbolTableStack) #importedClassifiers#).use(tn);
    if (x != null) {
      return x;
    }

    // Is it a class in the same package?
    String qn = packagePrefix + "." + tn;
    if (reflectiveGetType(qn) != null) {
      x = getOrCreateClassifierVertex(qn, ce);
      return x;
    }

    // Is it a class imported by a package import foo.bar.*?
    for (Object pn : ((SymbolTableStack) #importedPackages#)
                     .getTop().getMap().keySet()) {
      qn = pn + "." + tn;
      if (reflectiveGetType(qn) != null) {
        x = getOrCreateClassifierVertex(qn, ce);
        return x;
      }
    }

    // Is it a class from java.lang?
    qn = "java.lang." + tn;
    if (reflectiveGetType(qn) != null) {
      x = getOrCreateClassifierVertex(qn, ce);
      return x;
    }
    throw new RuntimeException("Couldn't resolve type " + tn);
  }
}

exports
  context-free start-symbols CompilationUnit
