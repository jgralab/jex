module java/Main
schema de.uni_koblenz.simple_java.schema.JavaSchema

imports
  java/CompilationUnits   %% CompilationUnit
  java/WhiteSpace
  java/Comments

symbol tables
  name2Package<Package>
  name2NamedElement<NamedElement>
  importedPackages<Package>             %% QName
  importedClassifiers<Classifier>       %% SimpleName
  importedClassifiersQN<Classifier>     %% QName
  typeParams<TypeParameter>

default values
  Imports.lineNo = line(omega);
  Defines.lineNo = line(omega);

import declarations
  java.util.List;
  java.util.LinkedList;
  java.util.Map;
  java.util.HashMap;
  java.util.regex.Pattern;
  java.util.regex.Matcher;
  java.lang.reflect.Method;
  java.lang.reflect.Modifier;
  java.lang.reflect.TypeVariable;
  de.uni_koblenz.simple_java.schema.Modifiers;
  de.uni_koblenz.jgralab.JGraLab;
  de.uni_koblenz.jgralab.TemporaryVertex;
  de.uni_koblenz.jgralab.EdgeDirection;
  de.uni_koblenz.edl.parser.Position;
  de.uni_koblenz.edl.parser.Rule;
  de.uni_koblenz.edl.parser.stack.elements.StackElement;
  org.pcollections.PSet;
  org.spoofax.jsglr.client.AbstractParseNode;
  org.spoofax.interpreter.terms.IStrategoTerm;


user code {
    private Vertex defaultPackage;

    {
        defaultPackage = createVertex("Package", new Position());
        defaultPackage.setAttribute("name","");
        defaultPackage.setAttribute("qualifiedName","");
    }

    private Map<String, Vertex> primTypes = new HashMap<String, Vertex>();
    {
        for (String n : new String[] {"boolean", "char", "byte", "short",
                                      "int", "long", "float", "double", "void"}) {
            Vertex p = getGraph().createVertex(de.uni_koblenz.simple_java.schema.PrimitiveType.VC);
            p.setAttribute("qualifiedName", n);
            p.setAttribute("name", n);
            p.setAttribute("type",
                de.uni_koblenz.simple_java.schema.PrimitiveTypes.valueOf(n.toUpperCase()));
            primTypes.put(n, p);
        }
    }

    private boolean isPackageDeclaration = false;
    // The qname of the element we are currently parsing (a Classifier)
    private String curQName;
    // The qname of the current package
    private String curPkgQName;

    @SuppressWarnings("unchecked")
    @Override
    public void finalize() {
        List<TemporaryVertex> tempVertices = (List<TemporaryVertex>)
            #name2NamedElement.getTemporaryVertices()#;
        for (TemporaryVertex tempVert: tempVertices) {
            if (tempVert.getPreliminaryType() != null) {
                tempVert.bless();
            } else {
                tempVert.bless(getVertexClass("Class"));
            }
        }
        List<TemporaryVertex> tempPackages = (List<TemporaryVertex>)
            #name2Package.getTemporaryVertices()#;
        for (TemporaryVertex tempPackage: tempPackages) {
            tempPackage.bless(getVertexClass("Package"));
        }
        for (Vertex tmp : getGraph().vertices(graph.getGraphClass()
                                    .getTemporaryVertexClass())) {
            System.out.println("Left over TemporaryVertex: " + tmp);
        }
        for (Edge tmp : getGraph().edges(graph.getGraphClass()
                                  .getTemporaryEdgeClass())) {
            System.out.println("Left over TemporaryEdge: " + tmp);
            System.out.println("  alpha: " + tmp.getAlpha());
            System.out.println("  omega: " + tmp.getOmega());
        }
    }

    private void initClassTypeParamsSymbolTable(String qname, StackElement ce) {
        Class c = reflectiveGetType(qname);
        SymbolTableStack stck = (SymbolTableStack) #typeParams#;
        for (TypeVariable<Class<?>> tv : c.getTypeParameters()) {
            Vertex tp = stck.useOrDeclare(tv.getName(),
                                          getVertexClass("TypeParameter"),
                                          ce.getPosition());
            tp.setAttribute("name", tv.getName());
            tp.setAttribute("qualifiedName", c.getName() + "." + tv.getName());
        }
    }

    private Class getTypeClass(String p, StackElement ce) {
        if (p.contains("[")) {
            return getArrayTypeClass(p, ce);
        } else if (primTypes.keySet().contains(p)) {
            return getPrimTypeClass(p, ce);
        } else {
            Vertex v = resolveClassifier(p, ce);
            return reflectiveGetType((String) v.getAttribute("qualifiedName"));
        }
    }

    private Class getArrayTypeClass(String t, StackElement ce) {
        String[] split = t.split("\\[");
        Class elemType = getTypeClass(split[0], ce);
        int dims = split.length - 1;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < dims; i++) {
            sb.append('[');
        }
        if (elemType.isPrimitive()) {
            char typeSpec = ' ';
            if (elemType == int.class)          typeSpec = 'I';
            else if (elemType == short.class)   typeSpec = 'S';
            else if (elemType == byte.class)    typeSpec = 'B';
            else if (elemType == char.class)    typeSpec = 'C';
            else if (elemType == long.class)    typeSpec = 'J';
            else if (elemType == float.class)   typeSpec = 'F';
            else if (elemType == double.class)  typeSpec = 'D';
            else if (elemType == boolean.class) typeSpec = 'Z';
            else if (elemType == void.class) throw new RuntimeException("There are no void-arrays.");
            else throw new RuntimeException("Cannot get class of '" + t + "'.");
            sb.append(typeSpec);
        } else {
            sb.append('L');
            sb.append(elemType.getName());
        }
        return reflectiveGetType(sb.toString());
    }

    private Class getPrimTypeClass(String t, StackElement ce) {
        if (t.equals("int")) return int.class;
        else if (t.equals("short"))   return short.class;
        else if (t.equals("byte"))    return byte.class;
        else if (t.equals("char"))    return char.class;
        else if (t.equals("long"))    return long.class;
        else if (t.equals("float"))   return float.class;
        else if (t.equals("double"))  return double.class;
        else if (t.equals("boolean")) return boolean.class;
        else if (t.equals("void"))    return void.class;
        else throw new RuntimeException("Cannot get class of '" + t + "'.");
    }

    private void initMethodTypeParamsSymbolTable(StackElement ce) {
        Class c = reflectiveGetType(curQName);

        char[] content = getFileContent();
        int i = ce.getOffset();
        int lastSpace = i;
        int startOfParamList = i;
        String methodName = null;
        String params = null;
        while (true) {
          if (Character.isWhitespace(content[i])) {
              lastSpace = i;
          } else if (content[i] == '(') {
              StringBuilder sb = new StringBuilder();
              for (int j = lastSpace + 1; j < i; j++) {
                  sb.append(content[j]);
              }
              methodName = sb.toString();
              startOfParamList = i;
          } else if (content[i] == ')') {
              StringBuilder sb = new StringBuilder();
              for (int j = startOfParamList + 1; j < i; j++) {
                  sb.append(content[j]);
              }
              params = sb.toString().replaceAll("\\s+", " ");
              break;
          }
          i++;
        }

        // Kill spaces before [, e.g., "int  []    []"
        params = params.replaceAll("\\s+\\[", "[");
        String[] typeNamePairs = params.split(",");
        List<Class> paramTypes = new LinkedList<Class>();
        for (String p : typeNamePairs) {
            p = p.trim();
            int idx = p.indexOf('<');
            if (idx != -1) {
                p = p.substring(0, idx);
            }
            idx = p.indexOf(" ");
            if (idx != -1) {
                p = p.substring(0, idx);
            }
            paramTypes.add(getTypeClass(p, ce));
            i++;
        }

        Method theMethod = null;
        try {
            theMethod = c.getMethod(methodName,
                                    paramTypes.toArray(new Class[paramTypes.size()]));
        } catch (Exception e) {
            throw new RuntimeException("Couldn't find generic method '" + methodName
                + "' in class '" + curQName + "'.", e);
        }

        SymbolTableStack stck = (SymbolTableStack) #typeParams#;
        for (TypeVariable<Method> tv : theMethod.getTypeParameters()) {
            Vertex tp = stck.useOrDeclare(tv.getName(),
                                          getVertexClass("TypeParameter"),
                                          ce.getPosition());
            tp.setAttribute("name", tv.getName());
            tp.setAttribute("qualifiedName", c.getName() + "." + tv.getName());
        }
    }


    private static Class reflectiveGetType(String qn) {
        List<String> l = nestedClassifierNames(qn);
        l.add(qn);
        for (String qname : l) {
            try {
                return Class.forName(qname, false,
                    Thread.currentThread().getContextClassLoader());
            } catch (ClassNotFoundException e) {
                // ignore
            }
        }
        return null;
    }

    private Vertex getOrCreateClassifierVertex(Class cls, StackElement ce) {
        assert (cls == null);

        String qn = cls.getName();
        SymbolTableStack stck = (SymbolTableStack) #name2NamedElement#;

        // Maybe there's already an existing vertex for this type
        Vertex vx = stck.use(qn);
        if (vx != null) {
            return vx;
        }

        TemporaryVertex x = createTemporaryVertex(ce.getPosition());
        if (cls.isInterface())
            x.setPreliminaryType(getVertexClass("Interface"));
        else if (cls.isEnum())
            x.setPreliminaryType(getVertexClass("Enum"));
        else if (cls.isAnnotation())
            x.setPreliminaryType(getVertexClass("Annotation"));
        else
            x.setPreliminaryType(getVertexClass("Class"));

        x.setAttribute("qualifiedName", qn);
        x.setAttribute("name", cls.getSimpleName());

        PSet<Modifiers> mods = JGraLab.set();
        int modifiers = cls.getModifiers();
        if (Modifier.isAbstract(modifiers) && !Modifier.isInterface(modifiers)) {
            mods = mods.plus(Modifiers.ABSTRACT);
        } else if (Modifier.isFinal(modifiers)) {
            mods = mods.plus(Modifiers.FINAL);
        } else if (Modifier.isPrivate(modifiers)) {
            mods = mods.plus(Modifiers.PRIVATE);
        } else if (Modifier.isProtected(modifiers)) {
            mods = mods.plus(Modifiers.PROTECTED);
        } else if (Modifier.isPublic(modifiers)) {
            mods = mods.plus(Modifiers.PUBLIC);
        } else if (Modifier.isStatic(modifiers)) {
            mods = mods.plus(Modifiers.STATIC);
        } else if (Modifier.isStrict(modifiers)) {
            mods = mods.plus(Modifiers.STRICTFP);
        }
        x.setAttribute("modifiers", mods);

        // Declare it in the symbol table!
        stck.declare(qn, x);
        return x;
    }

    private static List<String> nestedClassifierNames(String name) {
        List<String> l = new LinkedList<String>();
        StringBuilder sb = new StringBuilder(name);
        int idx = name.lastIndexOf('.');
        while (idx != -1) {
            sb.replace(idx, idx + 1, "$");
            name = sb.toString();
            l.add(name);
            idx = name.lastIndexOf('.');
        }
        return l;
    }

    private static String canonicalizeQName(Object typeSpec) {
        String tn = ((String) typeSpec);
        tn = tn.replaceAll("\\s+", " ");
        tn = tn.replaceAll("([,<>])\\s+", "$1");
        tn = tn.replaceAll("\\s+([,<>])", "$1");
        return tn.trim();
    }

    private Vertex resolveClassifier(Object tn, Object currentElement) {
        StackElement ce = (StackElement) currentElement;
        List<String> triedNames = new LinkedList<String>();

        // Is tn already fully qualified?
        String qn = canonicalizeQName(tn);
        Class cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it an imported class foo.bar.Baz?
        Vertex theClass = ((SymbolTableStack) #importedClassifiers#).use(qn);
        if (theClass != null) {
            return theClass;
        }

        // Is it a class nested in some imported class?
        for (Object iqn : ((SymbolTableStack) #importedClassifiersQN#)
                          .getTop().getMap().keySet()) {
            qn = iqn + "." + tn;
            cls = reflectiveGetType(qn);
            if (cls != null) {
                return getOrCreateClassifierVertex(cls, ce);
            }
            triedNames.add(qn);
        }

        // Is it this class itself?
        qn = curQName;
        if (curQName.endsWith("." + tn)) {
           cls = reflectiveGetType(qn);
           if (cls != null) {
               return getOrCreateClassifierVertex(cls, ce);
           }
           triedNames.add(qn);
        }

        // Is it a class nested in this class?
        qn = curQName + "." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // TODO: That's a hack for getting GraphIO parsed...
        // Maybe a reference to a nested class, and we are currently also in a
        // nested class?
        qn = curQName.replaceAll("\\.\\w+$", "." + tn);
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it a class nested in this classes' superclass or implemented
        // interfaces (transitively, including also the interfaces of
        // superclasses)?
        Class curCls = reflectiveGetType(curQName);
        LinkedList<Class> supers = new LinkedList<Class>();
        Class superClass = curCls.getSuperclass();
        if (superClass != null) { supers.offer(superClass); }
        for (Class iface : curCls.getInterfaces()) { supers.offer(iface); }
        while (!supers.isEmpty()) {
            Class superType = supers.poll();
            qn = superType.getName() + "." + tn;
            cls = reflectiveGetType(qn);
            if (cls != null) {
                return getOrCreateClassifierVertex(cls, ce);
            }
            triedNames.add(qn);
            superClass = superType.getSuperclass();
            if (superClass != null) { supers.offer(superClass); }
            for (Class superIface : superType.getInterfaces()) { supers.offer(superIface); }
        }

        // Is it a class in the same package?
        qn = curPkgQName + "." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it a class imported by a package import foo.bar.*?
        for (Object pn : ((SymbolTableStack) #importedPackages#)
                                     .getTop().getMap().keySet()) {
            qn = pn + "." + tn;
            cls = reflectiveGetType(qn);
            if (cls != null) {
                return getOrCreateClassifierVertex(cls, ce);
            }
            triedNames.add(qn);
        }

        // Is it a class from java.lang?
        qn = "java.lang." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        throw new RuntimeException("Couldn't resolve type " + tn
            + ".  I've tried " + triedNames
            + ".  Is your CLASSPATH ok?");
    }
}

exports
  context-free start-symbols CompilationUnit
