module java/Main
schema de.uni_koblenz.simple_java.schema.JavaSchema

imports
  java/CompilationUnits   %% CompilationUnit
  java/WhiteSpace
  java/Comments

symbol tables
  name2Package<Package>
  name2NamedElement<NamedElement>
  importedPackages<Package>             %% QName
  importedClassifiers<Classifier>       %% SimpleName
  importedClassifiersQN<Classifier>     %% QName
  typeParams<TypeParameter>

default values
  Imports.lineNo = line(omega);
  Defines.lineNo = line(omega);

import declarations
  java.util.List;
  java.util.LinkedList;
  java.util.Map;
  java.util.HashMap;
  java.lang.reflect.Modifier;
  java.lang.reflect.TypeVariable;
  de.uni_koblenz.simple_java.schema.Modifiers;
  de.uni_koblenz.jgralab.JGraLab;
  de.uni_koblenz.jgralab.TemporaryVertex;
  de.uni_koblenz.jgralab.EdgeDirection;
  de.uni_koblenz.edl.parser.Position;
  de.uni_koblenz.edl.parser.stack.elements.StackElement;
  org.pcollections.PSet;


user code {
    private Vertex defaultPackage;

    {
        defaultPackage = createVertex("Package", new Position());
        defaultPackage.setAttribute("name","");
        defaultPackage.setAttribute("qualifiedName","");
    }

    private Map<String, Vertex> primTypes = new HashMap<String, Vertex>();
    {
        for (String n : new String[] {"boolean", "char", "byte", "short",
                                      "int", "long", "float", "double", "void"}) {
            Vertex p = getGraph().createVertex(de.uni_koblenz.simple_java.schema.PrimitiveType.VC);
            p.setAttribute("qualifiedName", n);
            p.setAttribute("name", n);
            p.setAttribute("type",
                de.uni_koblenz.simple_java.schema.PrimitiveTypes.valueOf(n.toUpperCase()));
            primTypes.put(n, p);
        }
    }

    private boolean isPackageDeclaration = false;
    // The qname of the element we are currently parsing (a Classifier)
    private String curQName;
    // The qname of the current package
    private String curPkgQName;

    @SuppressWarnings("unchecked")
    @Override
    public void finalize() {
        List<TemporaryVertex> tempVertices = (List<TemporaryVertex>)
            #name2NamedElement.getTemporaryVertices()#;
        for (TemporaryVertex tempVert: tempVertices) {
            if (tempVert.getPreliminaryType() != null) {
                tempVert.bless();
            } else {
                tempVert.bless(getVertexClass("Class"));
            }
        }
        List<TemporaryVertex> tempPackages = (List<TemporaryVertex>)
            #name2Package.getTemporaryVertices()#;
        for (TemporaryVertex tempPackage: tempPackages) {
            tempPackage.bless(getVertexClass("Package"));
        }
        for (Vertex tmp : getGraph().vertices(graph.getGraphClass()
                                    .getTemporaryVertexClass())) {
            System.out.println("Left over TemporaryVertex: " + tmp);
        }
        for (Edge tmp : getGraph().edges(graph.getGraphClass()
                                  .getTemporaryEdgeClass())) {
            System.out.println("Left over TemporaryEdge: " + tmp);
            System.out.println("  alpha: " + tmp.getAlpha());
            System.out.println("  omega: " + tmp.getOmega());
        }
    }

    private void initTypeParamsSymbolTable(StackElement ce, boolean method) {
        char[] content = getFileContent();
        int i = ce.getOffset() + 1;
        int start = i;
        int nesting = 1;
        boolean inName = true;
        List<String> tps = new LinkedList<String>();
        while (true) {
            char c = content[i];
            if (inName && (c == '>' || Character.isWhitespace(c) || c == ',')) {
                inName = false;
                tps.add(String.valueOf(content, start, i - start).trim());
            }

            if (c == '<') {
                nesting++;
            } else if (c == '>') {
                nesting--;
            } else if ((c == ',') && (nesting == 1)) {
                start = ++i;
                inName = true;
            }
            if (nesting == 0) break;
            i++;
        }
        // System.out.println("TypeParams: " + tps);
        if (tps.isEmpty()) {
            throw new RuntimeException("No type parameters found tho there should be some!");
        }

        SymbolTableStack stck = (SymbolTableStack) #typeParams#;
        for (String tp : tps) {
            Vertex tpv = stck.useOrDeclare(tp,
                                           getVertexClass("TypeParameter"),
                                           ce.getPosition());
            tpv.setAttribute("name", tp);
            // TODO: hm, the type parameter of a method has no real qname...
            // at least encode the method name in it, too
            tpv.setAttribute("qualifiedName", curQName + "." + tp);
        }
    }


    private static Class reflectiveGetType(String qn) {
        List<String> l = nestedClassifierNames(qn);
        l.add(qn);
        for (String qname : l) {
            try {
                return Class.forName(qname, false,
                    Thread.currentThread().getContextClassLoader());
            } catch (ClassNotFoundException e) {
                // ignore
            }
        }
        return null;
    }

    private Vertex getOrCreateClassifierVertex(Class cls, StackElement ce) {
        assert (cls == null);

        String qn = cls.getName();
        SymbolTableStack stck = (SymbolTableStack) #name2NamedElement#;

        // Maybe there's already an existing vertex for this type
        Vertex vx = stck.use(qn);
        if (vx != null) {
            return vx;
        }

        TemporaryVertex x = createTemporaryVertex(ce.getPosition());
        if (cls.isInterface())
            x.setPreliminaryType(getVertexClass("Interface"));
        else if (cls.isEnum())
            x.setPreliminaryType(getVertexClass("Enum"));
        else if (cls.isAnnotation())
            x.setPreliminaryType(getVertexClass("Annotation"));
        else
            x.setPreliminaryType(getVertexClass("Class"));

        x.setAttribute("qualifiedName", qn);
        x.setAttribute("name", cls.getSimpleName());

        PSet<Modifiers> mods = JGraLab.set();
        int modifiers = cls.getModifiers();
        if (Modifier.isAbstract(modifiers) && !Modifier.isInterface(modifiers)) {
            mods = mods.plus(Modifiers.ABSTRACT);
        } else if (Modifier.isFinal(modifiers)) {
            mods = mods.plus(Modifiers.FINAL);
        } else if (Modifier.isPrivate(modifiers)) {
            mods = mods.plus(Modifiers.PRIVATE);
        } else if (Modifier.isProtected(modifiers)) {
            mods = mods.plus(Modifiers.PROTECTED);
        } else if (Modifier.isPublic(modifiers)) {
            mods = mods.plus(Modifiers.PUBLIC);
        } else if (Modifier.isStatic(modifiers)) {
            mods = mods.plus(Modifiers.STATIC);
        } else if (Modifier.isStrict(modifiers)) {
            mods = mods.plus(Modifiers.STRICTFP);
        }
        x.setAttribute("modifiers", mods);

        // Declare it in the symbol table!
        stck.declare(qn, x);
        return x;
    }

    private static List<String> nestedClassifierNames(String name) {
        List<String> l = new LinkedList<String>();
        StringBuilder sb = new StringBuilder(name);
        int idx = name.lastIndexOf('.');
        while (idx != -1) {
            sb.replace(idx, idx + 1, "$");
            name = sb.toString();
            l.add(name);
            idx = name.lastIndexOf('.');
        }
        return l;
    }

    private static String canonicalizeQName(Object typeSpec) {
        String tn = ((String) typeSpec);
        tn = tn.replaceAll("\\s+", " ");
        tn = tn.replaceAll("([,<>])\\s+", "$1");
        tn = tn.replaceAll("\\s+([,<>])", "$1");
        return tn.trim();
    }

    private Vertex resolveClassifier(Object tn, Object currentElement) {
        StackElement ce = (StackElement) currentElement;
        List<String> triedNames = new LinkedList<String>();

        // Is tn already fully qualified?
        String qn = canonicalizeQName(tn);
        Class cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it an imported class foo.bar.Baz?
        Vertex theClass = ((SymbolTableStack) #importedClassifiers#).use(qn);
        if (theClass != null) {
            return theClass;
        }

        // Is it a class nested in some imported class?
        for (Object iqn : ((SymbolTableStack) #importedClassifiersQN#)
                          .getTop().getMap().keySet()) {
            qn = iqn + "." + tn;
            cls = reflectiveGetType(qn);
            if (cls != null) {
                return getOrCreateClassifierVertex(cls, ce);
            }
            triedNames.add(qn);
        }

        // Is it this class itself?
        qn = curQName;
        if (curQName.endsWith("." + tn)) {
           cls = reflectiveGetType(qn);
           if (cls != null) {
               return getOrCreateClassifierVertex(cls, ce);
           }
           triedNames.add(qn);
        }

        // Is it a class nested in this class?
        qn = curQName + "." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // TODO: That's a hack for getting GraphIO parsed...
        // FIXME: Create a stack of parent classes when parsing and use it here!
        // Maybe a reference to a nested class, and we are currently also in a
        // nested class?
        qn = curQName.replaceAll("\\.\\w+$", "." + tn);
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it a class nested in this classes' superclass or implemented
        // interfaces (transitively, including also the interfaces of
        // superclasses)?
        Class curCls = reflectiveGetType(curQName);
        if (curCls != null) {
            // curCls may be null when a class declaration has an annotation, and now
            // we're looking up the annotation type.
            LinkedList<Class> supers = new LinkedList<Class>();
            Class superClass = curCls.getSuperclass();
            if (superClass != null) { supers.offer(superClass); }
            for (Class iface : curCls.getInterfaces()) { supers.offer(iface); }
            while (!supers.isEmpty()) {
                Class superType = supers.poll();
                qn = superType.getName() + "." + tn;
                cls = reflectiveGetType(qn);
                if (cls != null) {
                    return getOrCreateClassifierVertex(cls, ce);
                }
                triedNames.add(qn);
                superClass = superType.getSuperclass();
                if (superClass != null) { supers.offer(superClass); }
                for (Class superIface : superType.getInterfaces()) {
                    supers.offer(superIface);
                }
            }
        }

        // Is it a class in the same package?
        qn = curPkgQName + "." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        // Is it a class imported by a package import foo.bar.*?
        for (Object pn : ((SymbolTableStack) #importedPackages#)
                                     .getTop().getMap().keySet()) {
            qn = pn + "." + tn;
            cls = reflectiveGetType(qn);
            if (cls != null) {
                return getOrCreateClassifierVertex(cls, ce);
            }
            triedNames.add(qn);
        }

        // Is it a class from java.lang?
        qn = "java.lang." + tn;
        cls = reflectiveGetType(qn);
        if (cls != null) {
            return getOrCreateClassifierVertex(cls, ce);
        }
        triedNames.add(qn);

        throw new RuntimeException("Couldn't resolve type " + tn
            + ".  I've tried " + triedNames
            + ".  Is your CLASSPATH ok?");
    }
}

exports
  context-free start-symbols CompilationUnit
