module java/Main
schema de.uni_koblenz.simple_java.schema.JavaSchema

imports
  java/CompilationUnits   %% CompilationUnit
  java/WhiteSpace
  java/Comments

symbol tables
  name2Package<Package>
  name2NamedElement<NamedElement>
  name2Member<Member<--Declares>:Type
  importedPackages<Package>
  importedClassifiers<Classifier>

default values
  Imports.lineNo = line(omega);
  Defines.lineNo = line(omega);

import declarations
  java.util.List;
  de.uni_koblenz.jgralab.TemporaryVertex;
  de.uni_koblenz.edl.parser.Position;
  de.uni_koblenz.edl.parser.stack.elements.StackElement;

user code {
  private Vertex defaultPackage;
  
  {
    defaultPackage = createVertex("Package", new Position());
    defaultPackage.setAttribute("name","");
    defaultPackage.setAttribute("qualifiedName","");
  }
  
  private boolean isPackageDeclaration = false;
  private String packagePrefix;
  private int statements = 0;

  @SuppressWarnings("unchecked")
  @Override
  public void finalize() {
    List<TemporaryVertex> tempVertices = (List<TemporaryVertex>)
      #name2NamedElement.getTemporaryVertices()#;
    for (TemporaryVertex tempVert: tempVertices) {
      if (tempVert.getPreliminaryType() != null) {
        tempVert.bless();
      } else {
        tempVert.bless(getVertexClass("Class"));
      }
    }
    List<TemporaryVertex> tempPackages = (List<TemporaryVertex>)
      #name2Package.getTemporaryVertices()#;
    for (TemporaryVertex tempPackage: tempPackages) {
      tempPackage.bless(getVertexClass("Package"));
    }
    for (Vertex tmp : getGraph().vertices(graph.getGraphClass()
                                .getTemporaryVertexClass())) {
      System.out.println("Left over TemporaryVertex: " + tmp);
    }
    for (Edge tmp : getGraph().edges(graph.getGraphClass()
                                .getTemporaryEdgeClass())) {
      System.out.println("Left over TemporaryEdge: " + tmp);
      System.out.println("  alpha: " + tmp.getAlpha());
      System.out.println("  omega: " + tmp.getOmega());
    }
  }

  static String stripTypeParams(Object typeSpec) {
    String ts = (String) typeSpec;
    int idx = ts.indexOf('<');
    if (idx != -1)
      ts = ts.substring(0, idx);
    // System.out.println("Stripped TypeSpec " + typeSpec + " to " + ts);
    return ts;
  }

  // Rips out the simple name of a qualified name, possibly including type parameters
  static String getSimpleName(Object qn) {
    String qname = stripTypeParams(qn);
    int idx = qname.lastIndexOf('.');
    if (idx != -1)
      qname = qname.substring(idx + 1);
    // System.out.println("Stripped QName " + qn + " to simple name " + qname);
    return qname;
  }

  static boolean isQualified(Object qn) {
    return ((String) qn).indexOf('.') != -1;
  }

  Class reflectiveGetType(String qn) {
    try {
      return Class.forName(qn);
    } catch (ClassNotFoundException e) {
      return null;
    }
  }

  Vertex createTmpClassifierVertex(String qn, StackElement ce) {
    Class cls = reflectiveGetType(qn);
    if (cls == null) throw new RuntimeException("Unknown classifier: " + qn);
    Vertex x = null;
    if (cls.isInterface())
      x = createTemporaryVertex(getVertexClass("Interface"), ce.getPosition());
    else if (cls.isEnum())
      x = createTemporaryVertex(getVertexClass("Enum"), ce.getPosition());
    else if (cls.isAnnotation())
      x = createTemporaryVertex(getVertexClass("Annotation"), ce.getPosition());
    else
      x = createTemporaryVertex(getVertexClass("Class"), ce.getPosition());
    x.setAttribute("qualifiedName", qn);
    x.setAttribute("name", getSimpleName(qn));
    return x;
  }

  Vertex getRefedType(Object typeSpec, Object currentElement) {
    String tn = stripTypeParams(typeSpec);
    StackElement ce = (StackElement) currentElement;
    Vertex x = null;
    if (isQualified(tn)) {
      // TODO: This is false for nested types like SomeClass.SomeInnerClass
      x = ((SymbolTableStack) #name2NamedElement#).use(tn);
      if (x == null) {
        x = createTmpClassifierVertex(tn, ce);
        ((SymbolTableStack) #name2NamedElement#).declare(tn, x);
      }
      return x;
    } else {
      x = ((SymbolTableStack) #importedClassifiers#).use(tn);
      if (x != null) {
        return x;
      }
      String qn = packagePrefix + "." + tn;
      if (reflectiveGetType(qn) != null) {
        x = createTmpClassifierVertex(qn, ce);
        return x;
      }
      for (Object pn : ((SymbolTableStack) #importedPackages#)
                       .getTop().getMap().keySet()) {
        qn = pn + "." + tn;
        if (reflectiveGetType(qn) != null) {
          x = createTmpClassifierVertex(qn, ce);
          return x;
        }
      }
      // The type was not in this package and not in some imported package,
      // so it must be java.lang!
      qn = "java.lang." + tn;
      return createTmpClassifierVertex(qn, ce);
    }
  }
}

exports
  context-free start-symbols CompilationUnit
