module java/Main
schema de.uni_koblenz.simple_java.schema.JavaSchema

imports
  java/CompilationUnits   %% CompilationUnit
  java/WhiteSpace
  java/Comments

symbol tables
  name2Package<Package>
  name2NamedElement<NamedElement>
  name2Member<Member<--Declares>:Classifier
  importedPackages<Package>
  importedClassifiers<Classifier>

default values
  Imports.lineNo = line(omega);
  Defines.lineNo = line(omega);

import declarations
  java.util.List;
  java.util.LinkedList;
  de.uni_koblenz.jgralab.TemporaryVertex;
  de.uni_koblenz.edl.parser.Position;
  de.uni_koblenz.edl.parser.stack.elements.StackElement;

user code {
  private Vertex defaultPackage;
  
  {
    defaultPackage = createVertex("Package", new Position());
    defaultPackage.setAttribute("name","");
    defaultPackage.setAttribute("qualifiedName","");
  }
  
  private boolean isPackageDeclaration = false;
  // The qname of the element we are currently parsing
  private String curQName;
  private String curPkgQName;
  private int statements = 0;

  @SuppressWarnings("unchecked")
  @Override
  public void finalize() {
    List<TemporaryVertex> tempVertices = (List<TemporaryVertex>)
      #name2NamedElement.getTemporaryVertices()#;
    for (TemporaryVertex tempVert: tempVertices) {
      if (tempVert.getPreliminaryType() != null) {
        tempVert.bless();
      } else {
        tempVert.bless(getVertexClass("Class"));
      }
    }
    List<TemporaryVertex> tempPackages = (List<TemporaryVertex>)
      #name2Package.getTemporaryVertices()#;
    for (TemporaryVertex tempPackage: tempPackages) {
      tempPackage.bless(getVertexClass("Package"));
    }
    for (Vertex tmp : getGraph().vertices(graph.getGraphClass()
                                .getTemporaryVertexClass())) {
      System.out.println("Left over TemporaryVertex: " + tmp);
    }
    for (Edge tmp : getGraph().edges(graph.getGraphClass()
                                .getTemporaryEdgeClass())) {
      System.out.println("Left over TemporaryEdge: " + tmp);
      System.out.println("  alpha: " + tmp.getAlpha());
      System.out.println("  omega: " + tmp.getOmega());
    }
  }

  static String stripTypeParams(Object typeSpec) {
    String ts = (String) typeSpec;
    int idx = ts.indexOf('<');
    if (idx != -1)
      ts = ts.substring(0, idx);
    // System.out.println("Stripped TypeSpec " + typeSpec + " to " + ts);
    return ts;
  }

  // Rips out the simple name of a qualified name, possibly including type parameters
  static String getSimpleName(Object qn) {
    String qname = stripTypeParams(qn);
    int idx = qname.lastIndexOf('.');
    if (idx != -1)
      qname = qname.substring(idx + 1);
    // System.out.println("Stripped QName " + qn + " to simple name " + qname);
    return qname;
  }

  static boolean isQualified(Object qn) {
    return ((String) qn).indexOf('.') != -1;
  }

  Class reflectiveGetType(String qn) {
    try {
      return Class.forName(qn);
    } catch (ClassNotFoundException e) {
      return null;
    }
  }

  Vertex getOrCreateClassifierVertex(Class cls, StackElement ce) {
    assert (cls == null);
    String qn = cls.getName();
    SymbolTableStack stck = (SymbolTableStack) #name2NamedElement#;

    // Maybe there's already an existing vertex for this classifier
    Vertex vx = stck.use(qn);
    if (vx != null) {
      // TODO: Maybe check if the type and attr vals are correct...
      return vx;
    }

    TemporaryVertex x = createTemporaryVertex(ce.getPosition());
    if (cls.isInterface())
      x.setPreliminaryType(getVertexClass("Interface"));
    else if (cls.isEnum())
      x.setPreliminaryType(getVertexClass("Enum"));
    else if (cls.isAnnotation())
      x.setPreliminaryType(getVertexClass("Annotation"));
    else
      x.setPreliminaryType(getVertexClass("Class"));

    x.setAttribute("qualifiedName", qn);
    x.setAttribute("name", cls.getSimpleName());

    // Declare it in the symbol table!
    stck.declare(qn, x);
    return x;
  }

  Vertex resolveType(Object typeSpec, Object currentElement) {
    String tn = stripTypeParams(typeSpec);
    StackElement ce = (StackElement) currentElement;
    List<String> triedNames = new LinkedList<String>();

    // Is tn already fully qualified?
    String qn = tn;
    Class cls = reflectiveGetType(qn);
    if (cls != null) {
      return getOrCreateClassifierVertex(cls, ce);
    }
    triedNames.add(qn);

    // Is it an imported class foo.bar.Baz?
    Vertex x = ((SymbolTableStack) #importedClassifiers#).use(tn);
    if (x != null) {
      return x;
    }

    // Is it a class nested in this class?
    qn = curQName + "." + tn;
    cls = reflectiveGetType(qn);
    if (cls != null) {
      return getOrCreateClassifierVertex(cls, ce);
    }
    triedNames.add(qn);

    // Is it a class in the same package?
    qn = curPkgQName + "." + tn;
    cls = reflectiveGetType(qn);
    if (cls != null) {
      return getOrCreateClassifierVertex(cls, ce);
    }
    triedNames.add(qn);

    // Is it a class imported by a package import foo.bar.*?
    for (Object pn : ((SymbolTableStack) #importedPackages#)
                     .getTop().getMap().keySet()) {
      qn = pn + "." + tn;
      cls = reflectiveGetType(qn);
      if (cls != null) {
        return getOrCreateClassifierVertex(cls, ce);
      }
      triedNames.add(qn);
    }

    // Is it a class from java.lang?
    qn = "java.lang." + tn;
    cls = reflectiveGetType(qn);
    if (cls != null) {
      return getOrCreateClassifierVertex(cls, ce);
    }
    triedNames.add(qn);
    throw new RuntimeException("Couldn't resolve type " + tn
      + ".  I've tried " + triedNames
      + ".  Is your CLASSPATH ok?");
  }
}

exports
  context-free start-symbols CompilationUnit
